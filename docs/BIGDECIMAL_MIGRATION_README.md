# BigDecimal 마이그레이션 및 수평적 파티셔닝 가이드

## 📋 개요

한국(KOSPI)과 미국(NASDAQ) 주식의 가격 정밀도 차이를 해결하기 위해 Long에서 BigDecimal로 마이그레이션을 수행했습니다.

## �� 문제 상황

### 기존 문제점

- **KOSPI**: 원 단위 거래 (예: 50,000원) → Long으로 충분
- **NASDAQ**: 소수점 단위 거래 (예: 150.25달러) → 소수점 정밀도 필요
- **API 응답**: "211.2700" 같은 소수점 문자열 → `Long.parseLong()`에서 NumberFormatException 발생

### 핵심 이슈

금융 데이터에서 소수점 정밀도는 매우 중요합니다. 특히 미국 주식의 경우 센트 단위까지 정확한 가격 처리가 필요하며, 이는 투자 결정과 수익률 계산에 직접적인 영향을 미칩니다.

## 🔍 해결 방안 검토

### 1. BigDecimal 사용 (최종 선택)

#### 장점

- **정밀도 보장**: 소수점 계산의 정확성 보장
- **표준적 접근**: 금융 시스템에서 일반적으로 사용하는 방법
- **Java 표준**: Java에서 제공하는 표준 클래스
- **안정성**: 반올림 오차 없이 정확한 계산
- **확장성**: 다양한 소수점 자릿수 지원

#### 단점

- **성능**: Long보다 연산 속도가 느림
- **메모리**: Long보다 메모리 사용량이 많음
- **복잡성**: 비교 연산 시 `compareTo()` 메서드 사용 필요

### 2. Long + 스케일링 방식

#### 개념

소수점을 제거하고 정수로 변환하여 저장하는 방법

- 예: 150.25달러 → 1502500 (센트 단위로 저장)

#### 장점

- **성능**: 정수 연산으로 빠른 처리
- **메모리**: Long 타입으로 메모리 효율적
- **인덱싱**: 정수 기반 인덱스로 빠른 검색

#### 단점

- **복잡성**: 스케일링 로직 추가 필요
- **오류 위험**: 스케일링 과정에서 실수 가능성
- **가독성**: 개발자가 스케일을 항상 고려해야 함
- **표준성**: 금융 시스템에서 비표준적 접근

### 3. 수평적 파티셔닝

#### 개념

시장별로 테이블을 분할하여 각각 다른 데이터 타입 사용

- KOSPI 테이블: Long 타입 (원 단위)
- NASDAQ 테이블: BigDecimal 타입 (소수점 지원)

#### 장점

- **최적화**: 각 시장에 최적화된 데이터 타입 사용
- **성능**: 테이블 크기 감소로 쿼리 성능 향상
- **스케줄러 효율성**: 시장별 독립적인 데이터 수집

#### 단점

- **복잡성**: 테이블 분할로 인한 복잡성 증가
- **유지보수**: 시장별 다른 로직 관리 필요
- **초기 비용**: 마이그레이션 비용과 시간

### 4. Decimal 타입 사용

#### 개념

데이터베이스의 DECIMAL 타입을 활용하는 방법

#### 장점

- **데이터베이스 최적화**: DB 레벨에서 정밀도 보장
- **일관성**: DB와 애플리케이션 간 일관된 타입

#### 단점

- **플랫폼 의존성**: 데이터베이스별 구현 차이
- **JPA 복잡성**: JPA 매핑 시 추가 설정 필요

## 🎯 최종 의사결정: BigDecimal 선택

### 의사결정 기준

#### 1. **정확성 우선**

금융 시스템에서는 정확성이 성능보다 우선되어야 합니다. 소수점 계산 오류는 투자 결정에 치명적인 영향을 미칠 수 있습니다.

#### 2. **표준성**

BigDecimal은 Java 금융 시스템의 표준이며, 대부분의 금융 라이브러리와 호환됩니다.

#### 3. **유지보수성**

개발자가 스케일링을 고려할 필요 없이 직관적인 코드 작성이 가능합니다.

#### 4. **확장성**

향후 다른 시장이나 통화 추가 시에도 유연하게 대응할 수 있습니다.

### 거부된 대안들의 이유

#### Long + 스케일링

- **복잡성 증가**: 스케일링 로직으로 인한 버그 위험
- **가독성 저하**: 코드 리뷰와 디버깅 시 혼란
- **표준성 부족**: 금융 시스템에서 비표준적 접근

#### 수평적 파티셔닝

- **조기 최적화**: 현재 데이터량으로는 과도한 최적화
- **복잡성**: 현재 단계에서는 불필요한 복잡성 증가
- **유지보수 비용**: 시장별 다른 로직 관리 부담

## 🚀 향후 최적화: 수평적 파티셔닝

### 적용 시점

- **데이터량 증가**: 일일 거래량이 수백만 건 이상
- **성능 이슈**: 쿼리 응답 시간이 1초 이상
- **스케줄러 병목**: 데이터 수집 시간이 거래시간을 초과

### 예상 효과

#### 1. **스케줄러 성능 최적화**

- 현재: 모든 종목을 조회하여 시장별 필터링
- 개선: 시장별 테이블에서 직접 조회

#### 2. **테이블 스캔 최적화**

- 현재: 전체 테이블에서 market_type 필터링
- 개선: 시장별 테이블에서 부분 스캔

#### 3. **인덱스 최적화**

- KOSPI: 원 단위에 최적화된 인덱스
- NASDAQ: 소수점 정밀도에 최적화된 인덱스

#### 4. **스케줄러 분리**

- KOSPI 거래시간 (09:00-15:30): KOSPI 전용 스케줄러
- NASDAQ 거래시간 (22:30-05:00): NASDAQ 전용 스케줄러

### 구현 전략

#### 1단계: 성능 모니터링

- 테이블 크기와 쿼리 성능 지속적 관찰
- 스케줄러 실행 시간 측정
- 데이터 수집 병목 지점 파악

#### 2단계: 점진적 마이그레이션

- 읽기 전용 복제본으로 테스트
- 시장별 데이터 분리 검증
- 롤백 계획 수립

#### 3단계: 전체 적용

- 다운타임 최소화를 위한 단계적 전환
- 데이터 무결성 검증
- 성능 개선 효과 측정

## 📊 성능 비교 분석

### 현재 vs 수평적 파티셔닝

| 항목          | 현재 (BigDecimal) | 수평적 파티셔닝 |
| ------------- | ----------------- | --------------- |
| **정확성**    | 높음              | 높음            |
| **성능**      | 보통              | 높음            |
| **복잡성**    | 낮음              | 높음            |
| **유지보수**  | 쉬움              | 어려움          |
| **확장성**    | 보통              | 높음            |
| **초기 비용** | 낮음              | 높음            |

### 데이터량별 권장사항

#### 소규모 (일일 10만 건 이하)

- **권장**: BigDecimal 단일 테이블
- **이유**: 성능 이슈 없음, 단순한 구조 유지

#### 중규모 (일일 10만-100만 건)

- **권장**: BigDecimal + 인덱스 최적화
- **이유**: 적절한 성능, 복잡성 최소화

#### 대규모 (일일 100만 건 이상)

- **권장**: 수평적 파티셔닝 고려
- **이유**: 성능 최적화 필요, 복잡성 감수 가능

## 📝 결론 및 권장사항

### 현재 상태

- **BigDecimal 마이그레이션 완료**: KOSPI와 NASDAQ 모두 정확한 가격 처리
- **표준적 접근**: 금융 시스템에서 검증된 방법
- **안정성**: 소수점 계산의 정확성 보장

### 향후 계획

1. **단기 (3-6개월)**: BigDecimal 기반 안정적 운영
2. **중기 (6-12개월)**: 성능 모니터링 및 인덱스 최적화
3. **장기 (12개월+)**: 데이터량에 따른 수평적 파티셔닝 검토

### 핵심 원칙

1. **정확성 우선**: 금융 데이터의 정확성은 절대적
2. **점진적 최적화**: 성능 이슈 발생 시 단계적 개선
3. **표준 준수**: 검증된 방법과 도구 사용
4. **모니터링**: 지속적인 성능 관찰과 개선

### 최종 권장사항

- **현재**: BigDecimal 기반으로 안정적인 시스템 운영
- **성능 모니터링**: 테이블 크기와 쿼리 성능 지속적 관찰
- **데이터 증가 시**: 수평적 파티셔닝 검토 및 점진적 적용
